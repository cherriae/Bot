from __future__ import annotations

import numpy as np
import matplotlib.pyplot as plt

from typing import *


class Quadratics:
    """Quadratics

    Sets the coefficients attribute to a list of coefficients
    for the polynomial. Coefficients are taken from the input
    keyword arguments, defaulting to 0 if not provided.

    The index of each coefficient in the list corresponds to
    the power of that term. For example coefficients[0] is the
    constant term, coefficients[1] is the coefficient for the
    x term, etc.

    Args:
       coefficients: Keyword arguments specifying the coefficients
           for the polynomial.

    """

    def __init__(self, **coefficients):
        self.coefficients = [coefficients.get(chr(97 + i), 0) for i in range(len(coefficients))]

    def __str__(self):
        terms = [f"{self.coefficients[i]}x^{len(self.coefficients) - 1 - i}" for i in range(len(self.coefficients))]
        return " + ".join(terms)

    def find_rational_root(self):
        """Finds a rational root of the polynomial if one exists.

        Checks all possible rational roots based on the leading
        coefficient and constant term. Returns the first root found
        that makes the polynomial evaluate to 0, or None if no
        rational root exists.

        The possible roots are generated by finding all factors of the
        leading coefficient and constant term up to their absolute
        values. Each of these factors is checked by evaluating the
        polynomial at that value.

        Args:
           self: The Polynomial instance.

        Returns:
           int or None: The first rational root found that evaluates
           the polynomial to 0, or None if none found.

        """

        leading_coefficient = int(self.coefficients[0])  # Convert to int
        constant_term = int(self.coefficients[-1])  # Convert to int
        possible_roots = []

        for i in range(1, abs(constant_term) + 1):
            if constant_term % i == 0:
                possible_roots.extend((i, -i))

        for i in range(1, abs(leading_coefficient) + 1):
            if leading_coefficient % i == 0:
                possible_roots.extend((i, -i))

        # Take into account the value of 'a' in synthetic division
        a = int(self.coefficients[0])  # Convert to int

        for root in possible_roots:
            if self.evaluate(root) == 0:
                # Divide the root by 'a' to get the correct root
                return root / a

    def evaluate(self, x):
        """Evaluates the polynomial at the given x value.

        Substitutes the x value into each term of the polynomial
        and sums the results.

        Args:
           self: The Polynomial instance.
           x: The value to evaluate the polynomial at.

        Returns:
           The result of evaluating the polynomial at x.

        """

        return sum(
            self.coefficients[i] * (x ** (len(self.coefficients) - 1 - i))
            for i in range(len(self.coefficients)
                           )
        )

    def synthetic_division(self, root):
        """Performs synthetic division on the polynomial.

        Uses the provided root to divide the polynomial synthetically,
        returning the results of the division.

        The synthetic division proceeds by taking each coefficient in
        turn, multiplying it by the root and adding it to the next
        coefficient, and storing the result.

        Args:
           self: The Polynomial instance.
           root: The root to divide the polynomial by.

        Returns:
           A list containing the results of the synthetic division.

        """

        result = [0] * (len(self.coefficients) - 1)
        result[0] = self.coefficients[0]

        for i in range(1, len(self.coefficients) - 1):
            result[i] = self.coefficients[i] + root * result[i - 1]

        return result

    def factor(self):
        """Factors the polynomial into linear factors.

        Repeatedly finds rational roots using find_rational_root()
        and performs synthetic division using the roots to divide the
        polynomial.

        The factors are collected as Polynomial objects representing
        the linear factors (x - root).

        If no rational root is found, the leading coefficient is taken
        as a factor.

        Args:
           self: The Polynomial instance to factor.
        Returns:
           A list of Polynomial factors of the original polynomial.

        """

        factors = []

        while len(self.coefficients) > 1:
            root = self.find_rational_root()
            if root is not None:
                factors.append(Quadratics(a=1, b=-root * self.coefficients[0]))
                self.coefficients = self.synthetic_division(root * self.coefficients[0])
            else:
                factors.append(Quadratics(a=self.coefficients[0]))

        return factors

    def simplify(self):
        """Simplifies the polynomial into factored form.

        Uses the factor() method to find the factors of the
        polynomial. Joins the factors together with parentheses
        into a simplified factored expression.

        Args:
           self: The Polynomial instance to simplify.

        Returns:
           A string containing the polynomial in simplified factored
           form.

        """
        factors = self.factor()

        return "(" + ")(".join(map(str, factors)) + ")"


class CartesianGraph:
    """CartesianGraph

    This code defines a CartesianGraph class for plotting 2D graphs on a cartesian coordinate system. It initializes
    a matplotlib figure and axes, defines default ranges and ticks, and provides methods to configure the axes and
    plot functions.
    """
    X_MIN = -5
    X_MAX = 5
    Y_MIN = -5
    Y_MAX = 5

    TICKS = 1

    def __init__(self):
        self._fig, self._ax = plt.subplots(figsize=(10, 10))
        self.fig.patch.set_facecolor('#ffffff')

    @property
    def fig(self):
        return self._fig

    @property
    def ax(self):
        return self._ax

    def axes(self, x_min: Optional[int] = X_MIN, x_max: Optional[int] = X_MAX, y_min: Optional[int] = Y_MIN,
             y_max: Optional[int] = Y_MAX,
             ticks: Optional[int] = TICKS):
        """Configures the plot axes.

        Sets the x and y axis limits, removes spines, adds gridlines,
        labels, and ticks based on the provided optional parameters.

        Default values are used for any parameters not provided.

        Args:
           self: The Plotter instance.
           x_min: Optional minimum x value.
           x_max: Optional maximum x value.
           y_min: Optional minimum y value.
           y_max: Optional maximum y value.
           ticks: Optional tick interval.

        Returns:
           None. Modifies the axes of the plot in place.
        """

        self.ax.set(xlim=(x_min - 1, x_max + 1), ylim=(y_min - 1, y_max + 1), aspect='equal')

        self.ax.spines['bottom'].set_position('zero')
        self.ax.spines['left'].set_position('zero')
        self.ax.spines['top'].set_visible(False)
        self.ax.spines['right'].set_visible(False)

        self.ax.set_xlabel('$x$', size=14, labelpad=-24, x=1.02)
        self.ax.set_ylabel('$y$', size=14, labelpad=-21, y=1.02, rotation=0)

        x_ticks = np.arange(x_min, x_max + 1, ticks)
        y_ticks = np.arange(y_min, y_max + 1, ticks)
        self.ax.set_xticks(x_ticks[x_ticks != 0])
        self.ax.set_yticks(y_ticks[y_ticks != 0])
        self.ax.set_xticks(np.arange(x_min, x_max + 1), minor=True)
        self.ax.set_yticks(np.arange(y_min, y_max + 1), minor=True)

        self.ax.grid(which='both', color='blue', linewidth=1, linestyle='-', alpha=0.2)

    @staticmethod
    def plot(y: Callable, filename: Optional[str] = "graph.png"):
        """Plots a function and saves the plot to a file.

        Args:
         y: The function to plot.
         filename: The name of the file to save the plot to.

        Returns:
         True if the plot was successfully saved, otherwise raises the error.

        """

        x = np.linspace(-5, 10, 100)
        plt.plot(x, y(x), 'b', linewidth=2)
        try:
            plt.savefig(f"../ext/images/{filename}")
            plt.close()
            return True
        except Exception as e:
            raise e


e = Quadratics(a=9, b=18, c=9)
f = e.simplify()
print(f)
